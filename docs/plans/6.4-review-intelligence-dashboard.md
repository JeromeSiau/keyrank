# 6.4 Review Intelligence Dashboard

> **Objective**: AI-powered dashboard to extract actionable insights from reviews - feature requests, bug reports, and version-based sentiment analysis.

## User Stories

```
US-16.1: As a user, I want to automatically see feature requests extracted from reviews
         so I can prioritize development based on user demand.

US-16.2: As a user, I want to see bug reports grouped by type
         so I can identify critical issues affecting users.

US-16.3: As a user, I want to see the impact of each version on review sentiment
         so I can measure release quality.
```

## Overview

Building on existing sentiment/theme enrichment, this feature adds:
1. **Feature Request Extraction**: AI extracts and groups feature requests with priority
2. **Bug Report Aggregation**: Groups bug reports by type, platform, version
3. **Version Sentiment Analysis**: Tracks sentiment changes per app version

## Architecture

### Data Flow

```
Reviews (existing) â†’ AI Extraction Job â†’ ReviewInsights table â†’ Flutter UI
                                              â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â†“                         â†“                         â†“
              Feature Requests          Bug Reports            Version Sentiment
```

### Existing Assets to Leverage

From exploration:
- `AppReview.themes` (JSON) - Already extracts: bugs, crashes, performance, features, etc.
- `AppReview.sentiment` - positive/negative/neutral/mixed
- `AppReview.sentiment_score` - -1.00 to 1.00
- `EnrichmentJob` - Background AI processing pipeline
- `OpenRouterService` - AI integration

---

## Backend Implementation

### 1. Database Schema

#### Migration: `create_review_insights_table`

```php
Schema::create('review_insights', function (Blueprint $table) {
    $table->id();
    $table->foreignId('app_id')->constrained()->cascadeOnDelete();
    $table->enum('type', ['feature_request', 'bug_report']);
    $table->string('title', 255);  // AI-generated summary
    $table->text('description')->nullable();  // AI-generated description
    $table->json('keywords');  // Keywords that triggered this insight
    $table->integer('mention_count')->default(1);
    $table->enum('priority', ['low', 'medium', 'high', 'critical'])->default('medium');
    $table->enum('status', ['open', 'planned', 'in_progress', 'resolved', 'wont_fix'])->default('open');
    $table->string('platform')->nullable();  // ios, android, or null for both
    $table->string('affected_version')->nullable();  // First version where reported
    $table->date('first_mentioned_at');
    $table->date('last_mentioned_at');
    $table->timestamps();

    $table->index(['app_id', 'type', 'status']);
    $table->index(['app_id', 'type', 'priority']);
});

Schema::create('review_insight_mentions', function (Blueprint $table) {
    $table->id();
    $table->foreignId('review_insight_id')->constrained()->cascadeOnDelete();
    $table->foreignId('app_review_id')->constrained()->cascadeOnDelete();
    $table->timestamps();

    $table->unique(['review_insight_id', 'app_review_id']);
});
```

### 2. Models

#### `ReviewInsight` Model

```php
class ReviewInsight extends Model
{
    protected $fillable = [
        'app_id', 'type', 'title', 'description', 'keywords',
        'mention_count', 'priority', 'status', 'platform',
        'affected_version', 'first_mentioned_at', 'last_mentioned_at',
    ];

    protected $casts = [
        'keywords' => 'array',
        'first_mentioned_at' => 'date',
        'last_mentioned_at' => 'date',
    ];

    public function app() { return $this->belongsTo(App::class); }
    public function mentions() { return $this->hasMany(ReviewInsightMention::class); }
    public function reviews() { return $this->hasManyThrough(AppReview::class, ReviewInsightMention::class, 'review_insight_id', 'id', 'id', 'app_review_id'); }

    // Scopes
    public function scopeFeatureRequests($query) { return $query->where('type', 'feature_request'); }
    public function scopeBugReports($query) { return $query->where('type', 'bug_report'); }
    public function scopeOpen($query) { return $query->where('status', 'open'); }
    public function scopeHighPriority($query) { return $query->whereIn('priority', ['high', 'critical']); }
}
```

### 3. Service: `ReviewIntelligenceService`

```php
class ReviewIntelligenceService
{
    public function __construct(
        private OpenRouterService $openRouter
    ) {}

    /**
     * Extract insights from new reviews (called by job)
     */
    public function processReviews(App $app, Collection $reviews): void
    {
        // 1. Group reviews by potential insight type
        $featureReviews = $reviews->filter(fn($r) => $this->isFeatureRequest($r));
        $bugReviews = $reviews->filter(fn($r) => $this->isBugReport($r));

        // 2. Extract and cluster feature requests
        if ($featureReviews->isNotEmpty()) {
            $this->extractFeatureRequests($app, $featureReviews);
        }

        // 3. Extract and cluster bug reports
        if ($bugReviews->isNotEmpty()) {
            $this->extractBugReports($app, $bugReviews);
        }
    }

    private function isFeatureRequest(AppReview $review): bool
    {
        $themes = $review->themes ?? [];
        return in_array('features', $themes) ||
               preg_match('/\b(add|need|want|wish|please|would be nice|should have|missing)\b/i', $review->content);
    }

    private function isBugReport(AppReview $review): bool
    {
        $themes = $review->themes ?? [];
        return array_intersect(['bugs', 'crashes', 'performance'], $themes) ||
               preg_match('/\b(crash|bug|error|broken|not working|doesn\'t work|fails|stuck|freeze)\b/i', $review->content);
    }

    private function extractFeatureRequests(App $app, Collection $reviews): void
    {
        // Use AI to cluster and summarize feature requests
        $prompt = $this->buildFeatureExtractionPrompt($reviews);
        $result = $this->openRouter->chat($prompt);

        foreach ($result['features'] ?? [] as $feature) {
            $this->upsertInsight($app, 'feature_request', $feature, $reviews);
        }
    }

    private function extractBugReports(App $app, Collection $reviews): void
    {
        $prompt = $this->buildBugExtractionPrompt($reviews);
        $result = $this->openRouter->chat($prompt);

        foreach ($result['bugs'] ?? [] as $bug) {
            $this->upsertInsight($app, 'bug_report', $bug, $reviews);
        }
    }

    /**
     * Get version sentiment analysis
     */
    public function getVersionSentiment(App $app, ?int $limit = 10): array
    {
        return AppReview::where('app_id', $app->id)
            ->whereNotNull('version')
            ->whereNotNull('sentiment')
            ->select('version')
            ->selectRaw('COUNT(*) as review_count')
            ->selectRaw('AVG(CASE WHEN sentiment = "positive" THEN 100 WHEN sentiment = "neutral" THEN 50 ELSE 0 END) as sentiment_percent')
            ->selectRaw('AVG(rating) as avg_rating')
            ->selectRaw('MIN(reviewed_at) as first_review')
            ->selectRaw('MAX(reviewed_at) as last_review')
            ->groupBy('version')
            ->orderByDesc('last_review')
            ->limit($limit)
            ->get()
            ->toArray();
    }
}
```

### 4. Controller: `ReviewIntelligenceController`

```php
class ReviewIntelligenceController extends Controller
{
    public function __construct(
        private ReviewIntelligenceService $service
    ) {}

    /**
     * GET /apps/{app}/review-intelligence
     * Returns dashboard data: feature requests, bug reports, version sentiment
     */
    public function index(App $app): JsonResponse
    {
        $this->authorize('view', $app);

        return response()->json([
            'feature_requests' => ReviewInsight::where('app_id', $app->id)
                ->featureRequests()
                ->open()
                ->orderByDesc('mention_count')
                ->limit(10)
                ->get(),
            'bug_reports' => ReviewInsight::where('app_id', $app->id)
                ->bugReports()
                ->open()
                ->orderByDesc('priority')
                ->orderByDesc('mention_count')
                ->limit(10)
                ->get(),
            'version_sentiment' => $this->service->getVersionSentiment($app),
            'summary' => [
                'total_feature_requests' => ReviewInsight::where('app_id', $app->id)->featureRequests()->count(),
                'total_bug_reports' => ReviewInsight::where('app_id', $app->id)->bugReports()->count(),
                'high_priority_bugs' => ReviewInsight::where('app_id', $app->id)->bugReports()->highPriority()->open()->count(),
            ],
        ]);
    }

    /**
     * GET /apps/{app}/review-intelligence/feature-requests
     */
    public function featureRequests(App $app): JsonResponse
    {
        $this->authorize('view', $app);

        return response()->json([
            'data' => ReviewInsight::where('app_id', $app->id)
                ->featureRequests()
                ->withCount('mentions')
                ->orderByDesc('mention_count')
                ->paginate(20),
        ]);
    }

    /**
     * GET /apps/{app}/review-intelligence/bug-reports
     */
    public function bugReports(App $app): JsonResponse
    {
        $this->authorize('view', $app);

        return response()->json([
            'data' => ReviewInsight::where('app_id', $app->id)
                ->bugReports()
                ->withCount('mentions')
                ->orderByDesc('priority')
                ->orderByDesc('mention_count')
                ->paginate(20),
        ]);
    }

    /**
     * GET /apps/{app}/review-intelligence/insights/{insight}/reviews
     */
    public function insightReviews(App $app, ReviewInsight $insight): JsonResponse
    {
        $this->authorize('view', $app);

        return response()->json([
            'data' => $insight->reviews()
                ->orderByDesc('reviewed_at')
                ->paginate(20),
        ]);
    }

    /**
     * PATCH /apps/{app}/review-intelligence/insights/{insight}
     * Update insight status (planned, resolved, etc.)
     */
    public function updateInsight(Request $request, App $app, ReviewInsight $insight): JsonResponse
    {
        $this->authorize('update', $app);

        $validated = $request->validate([
            'status' => 'sometimes|in:open,planned,in_progress,resolved,wont_fix',
            'priority' => 'sometimes|in:low,medium,high,critical',
        ]);

        $insight->update($validated);

        return response()->json($insight->fresh());
    }
}
```

### 5. Job: `ExtractReviewInsightsJob`

```php
class ExtractReviewInsightsJob implements ShouldQueue
{
    use InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        public App $app,
        public ?Carbon $since = null
    ) {}

    public function handle(ReviewIntelligenceService $service): void
    {
        $reviews = AppReview::where('app_id', $this->app->id)
            ->whereNotNull('enriched_at')  // Only process enriched reviews
            ->when($this->since, fn($q) => $q->where('reviewed_at', '>=', $this->since))
            ->orderByDesc('reviewed_at')
            ->limit(500)
            ->get();

        if ($reviews->isEmpty()) {
            return;
        }

        $service->processReviews($this->app, $reviews);
    }
}
```

### 6. API Routes

```php
// In routes/api.php
Route::middleware('auth:sanctum')->group(function () {
    Route::prefix('apps/{app}/review-intelligence')->group(function () {
        Route::get('/', [ReviewIntelligenceController::class, 'index']);
        Route::get('/feature-requests', [ReviewIntelligenceController::class, 'featureRequests']);
        Route::get('/bug-reports', [ReviewIntelligenceController::class, 'bugReports']);
        Route::get('/insights/{insight}/reviews', [ReviewIntelligenceController::class, 'insightReviews']);
        Route::patch('/insights/{insight}', [ReviewIntelligenceController::class, 'updateInsight']);
    });
});
```

---

## Flutter Implementation

### 1. Models (Freezed)

#### `review_intelligence_model.dart`

```dart
@freezed
class ReviewIntelligence with _$ReviewIntelligence {
  const factory ReviewIntelligence({
    required List<InsightItem> featureRequests,
    required List<InsightItem> bugReports,
    required List<VersionSentiment> versionSentiment,
    required ReviewIntelligenceSummary summary,
  }) = _ReviewIntelligence;

  factory ReviewIntelligence.fromJson(Map<String, dynamic> json) =>
      _$ReviewIntelligenceFromJson(json);
}

@freezed
class InsightItem with _$InsightItem {
  const factory InsightItem({
    required int id,
    required String type,
    required String title,
    String? description,
    required List<String> keywords,
    required int mentionCount,
    required String priority,  // low, medium, high, critical
    required String status,    // open, planned, in_progress, resolved, wont_fix
    String? platform,
    String? affectedVersion,
    required DateTime firstMentionedAt,
    required DateTime lastMentionedAt,
  }) = _InsightItem;

  factory InsightItem.fromJson(Map<String, dynamic> json) =>
      _$InsightItemFromJson(json);
}

@freezed
class VersionSentiment with _$VersionSentiment {
  const factory VersionSentiment({
    required String version,
    required int reviewCount,
    required double sentimentPercent,  // 0-100
    required double avgRating,
    required DateTime firstReview,
    required DateTime lastReview,
  }) = _VersionSentiment;

  factory VersionSentiment.fromJson(Map<String, dynamic> json) =>
      _$VersionSentimentFromJson(json);
}

@freezed
class ReviewIntelligenceSummary with _$ReviewIntelligenceSummary {
  const factory ReviewIntelligenceSummary({
    required int totalFeatureRequests,
    required int totalBugReports,
    required int highPriorityBugs,
  }) = _ReviewIntelligenceSummary;

  factory ReviewIntelligenceSummary.fromJson(Map<String, dynamic> json) =>
      _$ReviewIntelligenceSummaryFromJson(json);
}
```

### 2. Repository

#### Add to `reviews_repository.dart` or create `review_intelligence_repository.dart`

```dart
class ReviewIntelligenceRepository {
  final Dio _dio;

  ReviewIntelligenceRepository(this._dio);

  Future<ReviewIntelligence> getIntelligence(int appId) async {
    final response = await _dio.get('/apps/$appId/review-intelligence');
    return ReviewIntelligence.fromJson(response.data);
  }

  Future<List<InsightItem>> getFeatureRequests(int appId, {int page = 1}) async {
    final response = await _dio.get(
      '/apps/$appId/review-intelligence/feature-requests',
      queryParameters: {'page': page},
    );
    return (response.data['data']['data'] as List)
        .map((e) => InsightItem.fromJson(e))
        .toList();
  }

  Future<List<InsightItem>> getBugReports(int appId, {int page = 1}) async {
    final response = await _dio.get(
      '/apps/$appId/review-intelligence/bug-reports',
      queryParameters: {'page': page},
    );
    return (response.data['data']['data'] as List)
        .map((e) => InsightItem.fromJson(e))
        .toList();
  }

  Future<List<Review>> getInsightReviews(int appId, int insightId) async {
    final response = await _dio.get(
      '/apps/$appId/review-intelligence/insights/$insightId/reviews',
    );
    return (response.data['data']['data'] as List)
        .map((e) => Review.fromJson(e))
        .toList();
  }

  Future<InsightItem> updateInsight(
    int appId,
    int insightId, {
    String? status,
    String? priority,
  }) async {
    final response = await _dio.patch(
      '/apps/$appId/review-intelligence/insights/$insightId',
      data: {
        if (status != null) 'status': status,
        if (priority != null) 'priority': priority,
      },
    );
    return InsightItem.fromJson(response.data);
  }
}
```

### 3. Providers

```dart
final reviewIntelligenceRepositoryProvider = Provider<ReviewIntelligenceRepository>((ref) {
  return ReviewIntelligenceRepository(ref.watch(dioProvider));
});

final reviewIntelligenceProvider = FutureProvider.family<ReviewIntelligence, int>((ref, appId) async {
  return ref.watch(reviewIntelligenceRepositoryProvider).getIntelligence(appId);
});

// For updating insight status
final updateInsightProvider = FutureProvider.family<InsightItem, ({int appId, int insightId, String? status, String? priority})>((ref, params) async {
  final result = await ref.watch(reviewIntelligenceRepositoryProvider).updateInsight(
    params.appId,
    params.insightId,
    status: params.status,
    priority: params.priority,
  );
  // Invalidate main provider to refresh
  ref.invalidate(reviewIntelligenceProvider(params.appId));
  return result;
});
```

### 4. UI Components

#### `review_intelligence_screen.dart` (or widget in app detail tabs)

Structure:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ§  Review Intelligence                            Last 30 days â–¼   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  FEATURE REQUESTS (AI-extracted)                    23 total       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ #1  "Dark mode"                           15 mentions       â”‚   â”‚
â”‚  â”‚     Priority: HIGH (frequently requested)                   â”‚   â”‚
â”‚  â”‚     [View mentions] [Mark as planned]                       â”‚   â”‚
â”‚  â”‚                                                             â”‚   â”‚
â”‚  â”‚ #2  "Widget support"                      11 mentions       â”‚   â”‚
â”‚  â”‚     Priority: HIGH                                          â”‚   â”‚
â”‚  â”‚     [View mentions] [Mark as planned]                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                     â”‚
â”‚  BUG REPORTS (AI-extracted)                         12 total       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ğŸ› "Crash on launch"          8 reports    iOS 17.2+        â”‚   â”‚
â”‚  â”‚ ğŸ› "Sync not working"         3 reports    After v2.3.1     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                     â”‚
â”‚  SENTIMENT BY VERSION                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ v2.3.1  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘  71%  â†“ from 89%  âš ï¸ ALERT    â”‚   â”‚
â”‚  â”‚ v2.3.0  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  89%  â† best release          â”‚   â”‚
â”‚  â”‚ v2.2.0  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘  78%                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  ğŸ’¡ v2.3.1 caused sentiment drop - check crash reports above      â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Implementation Tasks

### Phase 1: Backend (Tasks 1-5)

1. **Create migration for `review_insights` and `review_insight_mentions` tables**
2. **Create `ReviewInsight` and `ReviewInsightMention` models**
3. **Create `ReviewIntelligenceService` with AI extraction logic**
4. **Create `ReviewIntelligenceController` with API endpoints**
5. **Create `ExtractReviewInsightsJob` for background processing**

### Phase 2: Flutter (Tasks 6-10)

6. **Create Freezed models: `ReviewIntelligence`, `InsightItem`, `VersionSentiment`**
7. **Create `ReviewIntelligenceRepository` with API methods**
8. **Create Riverpod providers for review intelligence**
9. **Create `ReviewIntelligenceCard` widget (dashboard component)**
10. **Add Review Intelligence tab to app detail screen**

### Phase 3: Integration & Polish (Tasks 11-13)

11. **Add l10n strings for all new UI text (EN + FR + others)**
12. **Schedule job in console routes (daily at 06:00)**
13. **Add navigation and test end-to-end**

---

## Verification

After implementation:
1. Run `php artisan migrate` - should create new tables
2. Run `flutter pub run build_runner build` - should generate Freezed files
3. Run `flutter analyze` - no errors
4. Manual test: Navigate to app â†’ Review Intelligence tab â†’ verify data loads

---

## Notes

- Leverages existing sentiment/theme enrichment pipeline
- AI extraction happens in background job, not on-demand (cost control)
- Version sentiment uses existing data, no additional AI calls
- Status updates are synchronous (user marks as "planned", etc.)
